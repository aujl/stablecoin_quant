name: Codex request comment

description: Post a standardized Codex request comment with optional duplicate suppression and existing-comment checks.

inputs:
  github-token:
    description: Token with permission to create issue or pull request comments.
    required: true
  comment-body:
    description: The body of the comment to create.
    required: true
  trigger-text:
    description: Text used to describe the automation trigger and to detect duplicates.
    required: true
  dedupe:
    description: Set to "true" to skip creating a new comment when a matching bot comment already exists.
    required: false
    default: 'false'
  require-existing-comment:
    description: Set to "true" to only post when a matching existing comment is present.
    required: false
    default: 'false'
  existing-comment-query:
    description: Optional substring to search for when require-existing-comment is enabled. Defaults to trigger-text when omitted.
    required: false
    default: ''
  existing-comment-author:
    description: Optional login that an existing comment must match when require-existing-comment is enabled.
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: Submit Codex request comment
      uses: actions/github-script@v7
      env:
        COMMENT_BODY: ${{ inputs.comment-body }}
        TRIGGER_TEXT: ${{ inputs.trigger-text }}
        DEDUPE: ${{ inputs.dedupe }}
        REQUIRE_EXISTING_COMMENT: ${{ inputs.require-existing-comment }}
        EXISTING_COMMENT_QUERY: ${{ inputs.existing-comment-query }}
        EXISTING_COMMENT_AUTHOR: ${{ inputs.existing-comment-author }}
      with:
        github-token: ${{ inputs.github-token }}
        result-encoding: string
        script: |
          const commentBody = process.env.COMMENT_BODY;
          const triggerText = process.env.TRIGGER_TEXT;
          const dedupe = (process.env.DEDUPE || '').toLowerCase() === 'true';
          const requireExisting = (process.env.REQUIRE_EXISTING_COMMENT || '').toLowerCase() === 'true';
          const existingQueryInput = process.env.EXISTING_COMMENT_QUERY;
          const existingAuthor = process.env.EXISTING_COMMENT_AUTHOR;
          const existingQuery = existingQueryInput || triggerText;

          if (!commentBody) {
            core.setFailed('No comment body provided.');
            return;
          }
          if (!triggerText) {
            core.setFailed('No trigger text provided.');
            return;
          }

          if (!context.issue?.number) {
            core.setFailed('No issue or pull request number available in the current context.');
            return;
          }

          const comments = await github.paginate(github.rest.issues.listComments, {
            ...context.repo,
            issue_number: context.issue.number,
            per_page: 100
          });

          if (requireExisting) {
            const found = comments.some((comment) => {
              if (existingAuthor && comment.user?.login !== existingAuthor) {
                return false;
              }
              return comment.body?.includes(existingQuery);
            });

            if (!found) {
              core.info(`No existing comment found containing "${existingQuery}"${existingAuthor ? ` from ${existingAuthor}` : ''}. Skipping Codex request.`);
              return;
            }
          }

          if (dedupe) {
            const duplicate = comments.some((comment) => {
              if (comment.user?.login !== 'github-actions[bot]') {
                return false;
              }
              return comment.body?.includes(triggerText);
            });

            if (duplicate) {
              core.info(`Codex request already posted for trigger "${triggerText}". Skipping duplicate.`);
              return;
            }
          }

          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: commentBody
          });

          core.info('Codex request comment created.');
